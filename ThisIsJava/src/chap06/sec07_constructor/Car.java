package chap06.sec07_constructor;

public class Car {

	String menufacturer = "Hyundai Motors";
	String color;
	String modelNumber;	
	int cc;
	int maxSpeed;
	
	/*
	 * =======================================================
	 * 생성자, constructor
	 * =======================================================
	 * => new 연산자와 같이 사용되어 클래스로부터 객체(Instance)를 생성할 때 호출되고, 객체의 초기화를 담당한다.
	 * => 생성자를 통해서만 클래스의 객체를 생성할 수 있기 때문에 사용자가 생성자를 정의하지 않아도 JVM이 컴파일 할 때 기본 생성자를 만들어 바이트 코드를 완성한다.
	 * */
	Car() {}
	
	/*
	 * 사용자 정의 생성자
	 * => 사용자가 임의로 생성자를 정의했다면 JVM은 기본 생성자를 만들지 않는다.
	 * => 따라서 해당 클래스의 객체를 생성할 때는 정의된 대로 생성자를 호출해 사용해야 한다.
	 * 
	 * 매개변수를 갖는 생성자
	 * => 생성자의 주 임무가 객체의 필드를 초기화 하는 것이기 때문에 생성자를 정의할 때는 보통 필드를 초기화할 값들을 생성자의 매개변수로 명시한다.
	 * => 매개변수의 이름은 초기화 할 필드의 이름과 동일하게 짓는 게 관례이다. (변수가 어떤 것을 의미하는 지 명확하게 해준다.)
	 * => 생성자를 호출 할 때 매개변수는 생성자에 정의된 순서대로 입력한다.
	 * => 생성자의 실행 블록 내에서는 매개변수가 최고 우선순위를 갖기 때문에 매개변수와 이름이 같은 필드를 서로 구분하기 위해 'this'를 사용하여 필드에 접근한다.
	 * => 'this'는 생성자 호출로 생성된 객체 자신을 참조하는 변수로, 'this.필드명'은 '내 자신 객체의 어떤 필드'를 의미한다.
	 * */
	Car(String color, String modelNumber, int cc, int maxSpeed) {
		this.color = color;
		this.modelNumber = modelNumber;
		this.cc = cc;
		this.maxSpeed = maxSpeed;
	}
	
	/*
	 * =======================================================
	 * 생성자 오버로딩, constructor overloading
	 * =======================================================
	 * 외부의 다양한 데이터를 매개변수로 받아 객체를 생성하기 위해서는 생성자를 여러개 정의해 놓을 필요가 있다.
	 * 생성자가 하나만 정의되어 있다면, 주어진 여러 상황에 유연하게 대처하기 힘들다.
	 * 이를 해결하기 위해 자바는 생성자의 매개변수를 달리하여 여러개 정의할 수 있는 '오버로딩'을 허용한다.
	 * 
	 * '오버로딩'을 하기 위해선 지켜야 할 조건이 있다.
	 * => 매개변수의 타입, 갯수, 순서가 다르게 선언한다.
	 * => JVM은 데이터 타입으로 각각의 매개변수를 구분한다. 매개변수의 이름을 다르게 하더라도 타입이 같다면 JVM은 이 둘을 구분할 수 없다.
	 * => 따라서 오버로딩 된 각각의 생성자를 서로 구분하기 위해서는 우선적으로 매개변수의 '타입'을 다르게 명시해야 한다.
	 * => 매개변수의 타입이 모두 같다면 생성자마다 갖는 매개변수의 '갯수'를 다르게 정의하여 구분할 수 있다.
	 * => 마지막으로 매개변수의 타입과 갯수마저 갖다면 그 '순서'를 다르게 하여 구분할 수 있다.
	 * */
	Car(String color, String modelNumber, int cc) {
		this.color = color;
		this.modelNumber = modelNumber;
		this.cc = cc;
	}
	
	/*
	 * =======================================================
	 * this()를 활용한 생성자의 코드 중복 문제 해결
	 * =======================================================
	 * 오버로딩을 통해 생성자를 여러개 정의하다 보면 중복해서 적어야 하는 코드가 점점 늘어난다.
	 * 이는 시간, 메모리, 개발자의 노동 등 자원의 소모를 늘린다.
	 * 이러한 코드 중복 문제를 해결하기 위해 '객체 자신'을 지칭하는 this를 활용할 수 있다.
	 * 
	 * 생성자가 클래스의 이름과 같다는 것을 떠올리면 그 사용법을 쉽게 유추할 수 있다.
	 * 생성자: 클래스네임([매개변수 ...]) ---> 생성자 내 다른 생성자 호출: this([매개변수 ...])
	 * this()는 '이 객체의 생성자'를 의미하고, 이를 통해 이미 정의된 다른 생성자를 현재의 생성자에서 호출하여 이미 작성된 코드를 재사용할 수 있다.
	 * */
	Car(String color, String modelNumber) {
		this(color, modelNumber, 0, 0);
	}
	
	@Override
	public String toString() {
		return "Car [menufacturer=" + menufacturer + ", color=" + color + ", modelNumber=" + modelNumber + ", cc=" + cc
				+ ", maxSpeed=" + maxSpeed + "]";
	}
	
}
